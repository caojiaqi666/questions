
// function generateMatrix(str) {
//   let count = 0;
//   let arr = quanpai(str);
//   console.log('arr: ', arr);
//   let len = arr.length;
//   for (let i = 0; i < len; i++) {
//     if (arr[i].includes("acbcca")) {
//       console.log(arr[i]);
//       count++;
//     }
//   }
//   return count;
// }

// function quanpai(str) {
//   var result = [];
//   if (str.length <= 1) {
//     return [str];
//   } else {
//     for (let i = 0; i < str.length; i++) {
//       var c = str[i];
//       var newStr = str.slice(0, i) + str.slice(i + 1, str.length);
//       var l = quanpai(newStr);

//       for (var j = 0; j < l.length; j++) {
//         var temp = c + l[j];
//         if (temp.length == str.length) {
//           result.push(temp);
//         }
//       }
//     }
//   }
//   return Array.from(new Set(result));
// }

// let res = generateMatrix("dacbccab");
// console.log("res: ", res);

// function sum(a, arr) {
//   let sum = 0;
//   let arr1 = [];
//   function jj(arr) {
//     for (let i = 0; i < arr.length; i++) {
//       for (let j = i + 1; j < arr.length; j++) {
//         sum = arr[i] + arr[j];
//         if (!arr1.includes(sum)) {
//           arr1.push(sum);
//         }
//       }
//       if (i < arr.length) {
//         arr[i + 1] = arr[i] + arr[i + 1];
//         arr.unshift();
//         jj(arr);
//       }
//     }
//   }
//   jj(arr);
//   console.log("arr1: ", arr1);
// }

// let res = sum(4, [1, 3, 6, 6]);
// console.log("res: ", res);

function permute(input) {
  let permArr = [];
  let used = [];
  function main(input) {
    var i, ch;
    for (i = 0; i < input.length; i++) {
      ch = input.splice(i, 1)[0];
      used.push(ch);
      if (input.length == 0) {
        permArr.push(used.slice());
      }
      main(input);
      input.splice(i, 0, ch);
      used.pop();
    }
    return permArr;
  }
  return main(input);
}

function midNumSum(arr) {
  let permArr = permute(arr);
  let sum = 0;
  let len = permArr.length;

  for (let i = 0; i < len; i++) {
    if (permArr[i] % 2 !== 0) {
      let mid = permArr[(len - 1) / 2];
      sum += mid;
    }
  }

  return sum;
}
console.log(permute([1, 2, 3, 4]));


// 美团 2023届转正实习与2022届应届补招 技术综合-前端&移动端方向在线考试 - 正式考试阶段
// 编程题|20.0分1/1
// 异步操作
// 时间限制： 3000MS
// 内存限制： 589824KB题目描述：
// 小美因为各种原因无法按时返校。为了完成学业，小美只能在家里上网课。网课由n个课程视频组成，编号为1到n。每个视频都需要从头看到尾才算完成该部分的学习，且某些视频只能在看完指定的一些视频之后才能开始播放。因为小美的学习能力和她用来上网课的电脑性能都很强，所以小美可以同时观看任意多个课程视频。现在小美想知道，若她不眠不休地学习，每个课程视频最早能在她开始学习多长时间之后才能结束。


// 输入描述
// 第一行有一个正整数n(1<=n<=500) ，代表课程视频的数量。
// 接下来n行中的第i行开头有两个正整数L,C(1<=L<=100,0<=C<n)。L代表编号为 i 的视频的时长为L分钟。C代表该观看该视频之前需要看完指定的C个视频。若C为零，则该视频可以立即观看。否则这一行接下来有C个用空格分开的正整数，代表编号为i的视频所依赖的那些课程视频的编号。
// 数字间两两有空格隔开
// 输出描述
// 在一行内输出n个用空格分开的整数，第 i 个代表编号为 i 的课程视频最早在开始后多少分钟之后才能看完。

// 样例输入
// 3
// 4 0
// 2 2 1 3
// 3 0
// 样例输出
// 4 6 3

// 提示
// 如样例1所描述：共有3个视频，第一个时长为4分钟且可以立即观看。第二个时长为2分钟且只能在看完编号为1和3的视频后才能开始播放。第三个时长为3分钟且可以立即观看。因此小美可以同时播放1和3两个视频，并在1号视频播放完毕后开始播放2号视频。
// 规则
// 请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
// 点击“调试”亦可保存代码
// 编程题可以使用本地编译器，此页面不记录跳出次数








// 字符串重排
// 时间限制： 3000MS
// 内存限制： 589824KB题目描述：
// 给你一个只包含小写字符的字符串s，你可以按任意顺序重排这个字符串中的字符，请问重排过后的字符串中，最多能有多少个’acbcca’子串？
// 例如，字符串’dacbccab’中含1个’acbcca’子串，按其他方式重排后最多也只能包含1个’acbcca’子串；字符串’acbccaacccb’中含1个’acbcca’子串，但重排成’acbccacbcca’ 后包含了2个’acbcca’子串。


// 输入描述
// 一行，一个只包含小写字符的字符串s。
// 数据保证 ：1<=|s|<=10000
// 输出描述
// 输出一个整数，表示将输入的字符串s重排后，最多能包含多少个’acbcca’子串。

// 样例输入
// dacbccab
// 样例输出
// 1

// 提示
// 输入样例2
// acbccaacccb
//  
// 输出样例2
// 2
// 规则
// 请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
// 点击“调试”亦可保存代码
// 编程题可以使用本地编译器，此页面不记录跳出次数









// 美团 2023届转正实习与2022届应届补招 技术综合-前端&移动端方向在线考试 - 正式考试阶段
// 编程题|20.0分2/4
// 会合
// 时间限制： 3000MS
// 内存限制： 589824KB题目描述：
// 数轴上有n个点，从左到右编号分别为1,2,…,n。
// 小美在1号点，小团在n号点，现在要选择一个点作为他们会合的地点，他们期望选择的点能让小美和小团到达会合点的距离差值尽量小。
// 你的任务是输出最小的距离差。


// 输入描述
// 第1行是一个正整数n，表示数轴上有n个点。
// 第2行是n个空格隔开的正整数a1,a2,…,an，第 i 个数表示第 i 个点的坐标。 
// 2<=n<=100000，1<=ai<=200，保证a1<=a2<=…<=an
// 输出描述
// 输出一个整数，表示最小距离差值。

// 样例输入
// 2
// 5 7
// 样例输出
// 2

// 提示
// 输入样例2
// 3
// 5 8 9

// 输出样例2
// 2
// 规则
// 请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
// 点击“调试”亦可保存代码
// 编程题可以使用本地编译器，此页面不记录跳出次数


















// 7的倍数
// 时间限制： 3000MS
// 内存限制： 589824KB题目描述：
// 小美喜欢7的倍数。桌面上有一些卡片，每张卡片上都印有一个数字，小美想从中挑选一些卡片，使得卡片上的数字之和最大，由于小美很喜欢7的倍数，她同时还希望挑选出的卡片的数字之和是7的倍数，请问她能挑选出的最大数字之和是多少？（注意，小美也可以一张卡片都不挑选）


// 输入描述
// 第一行是一个正整数n，表示桌上有n张写有数字的卡片。
// 第二行有n个空格隔开的整数a1,a2,…,an，其中ai表示桌上第i张卡片上所写的数字。
// 1<=n<=50000, |ai|<=3000
// 输出描述
// 一行一个整数，表示小美能挑选出的最大数字之和（且和为7的倍数）。

// 样例输入
// 4
// 1 3 6 6
// 样例输出
// 7

// 提示
// 输入样例2
// 5
// -2 -6 15 4 5
//  
// 输出样例2
// 14
// 规则
// 请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
// 点击“调试”亦可保存代码
// 编程题可以使用本地编译器，此页面不记录跳出次数















// 中位数
// 时间限制： 3000MS
// 内存限制： 589824KB题目描述：
// 小团很喜欢中位数。现在给定一个序列，若其长度为奇数，那么其中位数是将序列中的数从小到大排序后位于正中间位置的数；若其长度为偶数，那么其中位数是将序列中的数从小到大排序后位于最中间的两个数的平均值。
// 现在给你一个长度为n的序列，小团想知道所有长度为奇数的区间的中位数之和为多少。


// 输入描述
// 第一行一个正整数n，表示序列中有n个数。
// 接下来一行n个空格隔开的正整数a1,a2,…an表示序列中n个数的值。
// 1<=n<=2000, 1<=ai<=100000，保证ai互不相同。
// 输出描述
// 一行一个正整数，表示给定序列中所有长度为奇数的区间的中位数之和。

// 样例输入
// 4
// 2 3 1 4
// 样例输出
// 15

// 提示
// 样例解释
// 长度为奇数的区间有[2], [3], [1], [4], [2 3 1], [3 1 4]
// 答案为2+3+1+4+2+3=15
// 规则
// 请尽量在全场考试结束10分钟前调试程序，否则由于密集排队提交，可能查询不到编译结果
// 点击“调试”亦可保存代码
// 编程题可以使用本地编译器，此页面不记录跳出次数